port module Main exposing (main)

-- External modules

import Json.Decode as JD
import Json.Encode as JE
import Task exposing (Task)
import Time exposing (Time)
import Dict


-- Internal modules

import Connection exposing (decodeConnection, errorResponse, successResponse, encodeResponse)
import Types exposing (..)
import Routes


-- Ports


port elmToJs : JsInterface -> Cmd msg


port jsToElm : (JsInterface -> msg) -> Sub msg



-- Elm architecture


main : Program ProgramConfig State Msg
main =
    Platform.programWithFlags
        { init = init
        , update = update
        , subscriptions = subscriptions
        }


init : ProgramConfig -> ( State, Cmd Msg )
init config =
    ( { config = config
      , pending = Dict.empty
      }
    , Cmd.none
    )


subscriptions : State -> Sub Msg
subscriptions state =
    Sub.batch <|
        (jsToElm ReceiveFromJs)
            :: (if Dict.isEmpty state.pending then
                    []
                else
                    [ Time.every Time.second CollectGarbage ]
               )


update : Msg -> State -> ( State, Cmd Msg )
update msg state =
    let
        ( pending, cmd ) =
            case msg of
                ReceiveFromJs jsData ->
                    updateFromJs state jsData

                HandlerTaskResult conn handlerState ->
                    updateHandlerState conn state.pending handlerState

                CollectGarbage now ->
                    updateGarbageCollector state now
    in
        ( { state | pending = pending }, cmd )


{-| Endpoint handler state machine
An endpoint handler generates a sequence of `EndpointState`s, each describing an effect
it wants to do. Here we run those effects, then advance the handler to its next state.
-}
updateHandlerState : Connection -> PendingHandlers -> EndpointState -> ( PendingHandlers, Cmd Msg )
updateHandlerState conn pendingHandlers handlerState =
    case Debug.log "handlerState" handlerState of
        -- Handler is waiting for an async `Task` effect.
        -- When the effect is done, Elm will send us a `Msg` containing the
        -- next `EndpointState` (and the relevant `Connection`)... and round we go again.
        AwaitingTask task ->
            ( pendingHandlers
            , Task.perform (HandlerTaskResult conn) task
            )

        -- Handler is waiting for some data from a JS `port` effect.
        -- Next handler state will be generated by the continuation function.
        -- We can't send the function through a `port` so we store it in the app state,
        -- along with the relevant `Connection`.
        AwaitingPort effect continuation ->
            ( Dict.insert conn.id ( conn, continuation ) pendingHandlers
            , jsActionCmd (JsEffect effect) conn
            )

        -- Handler is not waiting for anything. Respond to client.
        HandlerData json ->
            ( pendingHandlers
            , jsActionCmd RespondToClient <| successResponse json conn
            )

        -- Handler has returned an error state. Respond to client.
        HandlerError endpointError ->
            ( pendingHandlers
            , jsActionCmd RespondToClient <| errorResponse endpointError conn
            )


{-| JS has sent us a message. Figure out what to do with it.
-}
updateFromJs : State -> JsInterface -> ( PendingHandlers, Cmd Msg )
updateFromJs state jsData =
    case decodeDataFromJs jsData of
        -- New connection from a client.
        -- Dispatch to a handler, and start iterating through its `EndpointState`s
        NewConnection conn ->
            (Routes.dispatch state.config conn)
                |> updateHandlerState conn state.pending

        -- Intermediate result returned from a JS action (which we must have requested earlier)
        -- Find the connection, and the current handler state, then resume execution
        JsActionResult connId jsValue ->
            case Dict.get connId state.pending of
                Just ( conn, continueWith ) ->
                    continueWith jsValue
                        |> updateHandlerState
                            conn
                            (Dict.remove connId state.pending)

                Nothing ->
                    Debug.log ("JsActionResult. Connection not found:\n" ++ toString connId)
                        ( state.pending, Cmd.none )

        -- Something went wrong in JS. Send an error response if we can.
        InboundPortError connId str ->
            case Dict.get connId state.pending of
                Just ( conn, _ ) ->
                    ( Dict.remove connId state.pending
                    , jsActionCmd RespondToClient <|
                        errorResponse
                            { status = InternalError
                            , messages = [ "InboundPortError", str ]
                            }
                            conn
                    )

                Nothing ->
                    Debug.log ("InboundPortError. Connection not found:\n" ++ toString connId)
                        ( state.pending, Cmd.none )


decodeDataFromJs : JsInterface -> InboundPortData
decodeDataFromJs jsData =
    let
        decoder =
            case jsData.tag of
                "NewConnection" ->
                    JD.map NewConnection (decodeConnection jsData.connectionId)

                "JsActionResult" ->
                    JD.map2 JsActionResult
                        (JD.succeed jsData.connectionId)
                        JD.value

                "JsError" ->
                    JD.map2 InboundPortError
                        (JD.succeed jsData.connectionId)
                        JD.string

                _ ->
                    JD.fail "Unknown tag, JS -> Elm"
    in
        case JD.decodeValue decoder jsData.payload of
            Ok portData ->
                portData

            Err str ->
                InboundPortError jsData.connectionId str


{-| Send an action to JavaScript `port`
Choices are deliberately limited, defined using Elm types, but easily extensible.
Structure inspired by Murphy Randle's talk from Elm Conf US 2017
Use Node for crypto - it's fast optimised C code, tested by tons of folks.
-}
jsActionCmd : OutboundPortAction -> Connection -> Cmd Msg
jsActionCmd elmData conn =
    let
        constructorToString x =
            toString x |> String.words |> List.head |> Maybe.withDefault ""

        tag =
            case elmData of
                RespondToClient ->
                    constructorToString elmData

                JsEffect effect ->
                    constructorToString effect
    in
        elmToJs
            { connectionId = conn.id
            , tag = tag
            , payload =
                case elmData of
                    RespondToClient ->
                        encodeResponse conn.response

                    JsEffect effect ->
                        case effect of
                            HashPassword plain ->
                                JE.string plain

                            CheckPassword { hash, salt, plainText } ->
                                JE.object
                                    [ ( "hash", JE.string hash )
                                    , ( "salt", JE.string salt )
                                    , ( "plainText", JE.string plainText )
                                    ]

                            SqlQuery { sql, values } ->
                                JE.object
                                    [ ( "dbClient", conn.dbClient )
                                    , ( "sql", JE.string sql )
                                    , ( "values", JE.list values )
                                    ]
            }


{-| Garbage Collection
When we call out to JS, we save the state of the endpoint handler until JS responds.
But if our JS code has a bug, it might *never* respond, and that's a memory leak.
Elm is all about safety, so let's guard against this edge-case by checking every so often.
Abandon any connections that have been waiting around too long, and respond with an error.
-}
updateGarbageCollector : State -> Time -> ( PendingHandlers, Cmd Msg )
updateGarbageCollector state now =
    let
        timeout =
            state.config.jsActionTimeout

        -- Optimise for the case where there's no garbage, since that's very likely.
        -- In this case the existing Dict should be passed through rather than rebuilt.
        ( newPending, dumpCmds ) =
            Dict.foldl
                (separateGarbage timeout now)
                ( state.pending, [] )
                state.pending
    in
        ( newPending, Cmd.batch dumpCmds )


separateGarbage :
    Time
    -> Time
    -> ConnectionId
    -> ( Connection, c )
    -> ( PendingHandlers, List (Cmd Msg) )
    -> ( PendingHandlers, List (Cmd Msg) )
separateGarbage timeout now ( timestamp, seq ) ( conn, _ ) ( pending, dumpCmds ) =
    if conn.timestamp - now <= timeout then
        ( pending, dumpCmds )
    else
        let
            dumpConnection =
                jsActionCmd RespondToClient <|
                    errorResponse
                        { status = InternalError
                        , messages = [ "JS action timeout" ]
                        }
                        conn
        in
            ( Dict.remove ( timestamp, seq ) pending
            , dumpConnection :: dumpCmds
            )
